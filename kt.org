#+begin_src latex
  \section{Introduction}
  Programs like BLAST are based on exact matching of potentially large
  sets of words, or \emph{patterns}. Such set matching is often done
  using keyword trees~\cite{aho75:eff}. Say we'd like to match the five
  patterns
  \begin{center}
    \begin{tabular}{ll}
      $p_1$ & \texttt{ATTT}\\
      $p_2$ & \texttt{ATTC}\\
      $p_3$ & \texttt{AT}\\
      $p_4$ & \texttt{TG}\\
      $p_5$ & \texttt{TT}
    \end{tabular}
  \end{center}

  The corresponding keyword tree consists of nodes, edges, and their
  labels. It is constructed by inserting each pattern into a growing
  intermediate tree. We begin with the first pattern, draw a root, and a
  node for each character in $p_1$ (Figure~\ref{fig:kt1}A). Except for
  the root, each node, $v$, thus has one incoming edge labeled with a
  character, $c=\mbox{in}(v)$.

  The last node we add, is labeled 1 to mark that its path label, that
  is, the concatenated characters of the path from the root to $v$,
  corresponds to $p_1$. Next, we add $p_2$ by matching it from the root
  into the tree. The prefix \texttt{ATT} is found and extended by
  \texttt{G} (Figure~\ref{fig:kt1}B). Similarly, $p_3$ is inserted, but
  stops at an internal node, which is labeled accordingly
  (Figure~\ref{fig:kt1}C). The next patter, $p_4$, cannot be matched
  into the tree, so it branches off at the root
  (Figure~\ref{fig:kt1}D). This branch is branched by the addition of
  the last pattern, $p_5$ (Figure~\ref{fig:kt1}E).

  Now each pattern is contained in the tree, and common prefixes such as
  \texttt{ATT} are summarized into unique path labels. This compression
  of common prefixes is the starting point for simultaneously searching
  for all five patterns in a text like
  \[
  T=\texttt{ATGATTC}
  \]

  \begin{figure}
    \begin{center}
      \resizebox{\textwidth}{!}{
      \begin{tabular}{ccccc}
	\textbf{A} & \textbf{B} & \textbf{C}  & \textbf{D} & \textbf{E}\\
	\input{kt1a} & \input{kt1b} & \input{kt1c} & \input{kt1d} & \input{kt1e}
      \end{tabular}
      }
    \end{center}
    \caption{Stepwise construction of the keyword tree for $p_1=\texttt{ATTT}$ (\textbf{A}), $p_2=\texttt{ATTC}$ (\textbf{B}), 
  $p_3=\texttt{AT}$ (\textbf{C}), $p_4=\texttt{TG}$ (\textbf{D}), and
      $p_5=\texttt{TT}$ (\textbf{E}).}\label{fig:kt1}
  \end{figure}

  Algorithm~\ref{alg:sm1} summarizes the steps for doing this. Matching
  begins at the first position in $T$, and at the root of the tree
  (lines 1 \& 2). While there is an edge $v\rightarrow v'$ labeled
  $T[j]$ (line 4), check whether node $v'$ is labeled $i$ (line 5). If
  so, output that $p_i$ was found (line 6). It ends at $j$, but it is
  customary to report its start at $j-|p_i|+1$. Then move $v$ to $v'$
  and advance to the next character in the text (lines 8 \& 9). With our
  example tree and text, we'd match \texttt{AT} and report finding
  $p_3$.

  \begin{algorithm}
    \caption{Provisional set matching
      algorithm~\cite{aho75:eff}.}\label{alg:sm1}
    \begin{algorithmic}[1]
      \input{ahoCor1}
    \end{algorithmic}
  \end{algorithm}

  We've now run out of matches, at which point we might be tempted to
  give up and return to the root. However, the $\texttt{T}$ we last
  matched can be extended to possibly discover the patterns that start
  with a \texttt{T}, $p_4$ or $p_5$. Returning to the root would require
  matching that \texttt{T} a second time. To avoid this, every node,
  $v$, has a \emph{failure link} connecting it to the node with the
  longest path label that is a suffix of the path label of $v$. The
  failure link of $v$ is found by visiting its parent's failure link,
  $w=\mbox{fail}(\mbox{parent}(v))$. If that has an outgoing edge
  $w\rightarrow w'$ with $\mbox{in}(w')=\mbox{in}(v)$, then the failure
  link of $v$ points to $w'$. Otherwise, the procedure is repeated
  until the root is reached. If no match is found in this way, the root
  is set as the failure link. Figure~\ref{fig:kt2} shows our example
  tree with failure links.

  \begin{figure}
    \begin{center}
      \input{kt2}
    \end{center}
    \caption{The keyword tree in Figure~\ref{fig:kt1}E with failure links.}\label{fig:kt2}
  \end{figure}

  In this way we find in our example text $p_4$ and $p_2$. At this point
  we see the utility of the sentinel character, $\$$, which
  terminates $T$. Otherwise, $T$ would end in a match and we'd attempt
  to access a character beyond the end of $T$ in line 4.

  Another thing to realize at this point is that by walking down the
  path of $p_2$, we've missed $p_5$. This is fixed by constructing
  \emph{output sets} that consist of all patterns that lie along the
  failure links connecting $v$ to the root. Figure~\ref{fig:kt3} shows
  Figure~\ref{fig:kt2} with output sets, one of which, $\{1, 5\}$,
  contains two patterns. Now, whenever \texttt{ATT} has been matched,
  the match to \texttt{TT} is also detected. Algorithm~\ref{alg:sm2} is
  derived from Algorithm~\ref{alg:sm1} by amending the output routine in
  the if-clause of lines 5--7.

  \begin{figure}
    \begin{center}
      \input{kt3}
    \end{center}
    \caption{The keyword tree in Figure~\ref{fig:kt2} with output sets.}\label{fig:kt3}
  \end{figure}

  \begin{algorithm}
    \caption{Final set matching
      algorithm~\cite{aho75:eff}.}\label{alg:sm2}
    \begin{algorithmic}[1]
      \input{ahoCor2}
    \end{algorithmic}
  \end{algorithm}

  To summarize, we construct a keyword tree by adding patterns, setting
  the failure links, and constructing the output sets.

  \section{Implementation}
  !Package \texttt{kt} implements set matching using keyword trees.

  The package outline contains hooks for imports, types, variables,
  methods, and functions.
#+end_src
#+begin_src go <<kt.go>>=
  package kt

  import (
	  //<<Imports>>
  )
  //<<Types>>
  //<<Variables>>
  //<<Methods>>
  //<<Functions>>
#+end_src
#+begin_src latex
    We first construct a keyword tree, then use it to search a text.
    \subsection{Construction}
    A keyword tree consists of nodes and edges, both of which are
    denoted in a structure with seven fields:
    \begin{enumerate}
    \item child node
    \item sibling node
    \item parent node
    \item character on incoming edge
    \item depth, that is, the length of the label from the root
    \item output set
    \item identifier
    \end{enumerate}
#+end_src
#+begin_src go <<Types>>=
  type Node struct {
	  child, sib, parent, fail *Node
	  in byte
	  depth int
	  output []int
	  id int
  }
#+end_src
#+begin_src latex
  !Function \texttt{NewKeywordTree} takes as argument a set of patterns
  !and returns the root of the tree representing these patterns.

  We construct the root, add the patterns, construct the failure links
  and output sets, and return the root.
#+end_src
#+begin_src go <<Functions>>=
  func NewKeywordTree(patterns []string) *Node {
	  root := new(Node)
	  for i, pattern := range patterns {
		  //<<Add pattern>>
	  }
	  //<<Construct failure links>>
	  //<<Construct output sets>>
	  return root
  }
#+end_src
#+begin_src latex
  A pattern is added by first finding the matching prefix, then adding
  the rest.
#+end_src
#+begin_src go <<Add pattern>>=
  //<<Match prefix>>
  //<<Add rest>>
#+end_src
#+begin_src latex
  The prefix is matched by moving along the pattern and into the
  tree. For each character in the pattern, the matching child is located
  and moved to. Since locating a child is also used later on when
  finding a failure link, we delegate it to a method.
#+end_src
#+begin_src go <<Match prefix>>=
  v := root
  var j int
  for j = 0; j < len(pattern); j++ {
	  c  := v.findChild(pattern[j])
	  if c != nil {
		  v = c
	  } else {
		  break
	  }
  }
#+end_src
#+begin_src latex
  To locate a match among the children of node $v$, start at its child
  and move along its siblings.
#+end_src
#+begin_src go <<Methods>>=
  func (v *Node) findChild(c byte) *Node {
	  child := v.child
	  for child != nil && child.in != c {
		  child = child.sib
	  }
	  return child
  }
#+end_src
#+begin_src latex
  To add the rest of the pattern, extend $v$ by a node for every
  character left in the pattern. The output set of the last node added
  gets the pattern's label.
#+end_src
#+begin_src go <<Add rest>>=
  for k := j; k < len(pattern); k++ {
	  child := new(Node)
	  //<<Initialize child>>
	  //<<Insert child>>
	  v = child
  }
  v.output = append(v.output, i)
#+end_src
#+begin_src latex
  We set the child's parent, the label of its incoming edge, its depth,
  and its identifier.
#+end_src
#+begin_src go <<Initialize child>>=
  child.parent = v
  child.in = pattern[k]
  child.depth = v.depth + 1
  child.id = nodeId
  nodeId++
#+end_src
#+begin_src latex
  The variable \texttt{nodeId} is global. We start counting at 1, which
  leaves zero as the root's ID. 
#+end_src
#+begin_src go <<Variables>>=
  var nodeId = 1
#+end_src
#+begin_src latex
  The child is inserted as the latest sibling among its parent's
  children.
#+end_src
#+begin_src go <<Insert child>>=
  if v.child == nil {
	  v.child = child
  } else {
	  cp := v.child
	  for cp.sib != nil {
		  cp = cp.sib
	  }
	  cp.sib = child
  }
#+end_src
#+begin_src latex
  We have now added all patterns to the tree, which concludes the first
  step in tree construction. In the second step, we add one failure link
  to each node.

  Failure links are constructed during breadth-first traversal of the
  tree. The function \texttt{breadthFirst} takes as arguments the root
  and a function applied to every node. This function might have
  arguments, which are also part of the argument list of
  \texttt{breadthFirst}. In our case, the function is called
  \texttt{setFailureLink} and its argument is the default failure link,
  the root.
#+end_src
#+begin_src go <<Construct failure links>>=
  breadthFirst(root, setFailureLink, root)
#+end_src
#+begin_src latex
  The function \texttt{breadthFirst} traverses the tree and applies
  \texttt{fn} to every node.
#+end_src
#+begin_src go <<Functions>>=
  func breadthFirst(v *Node, fn nodeAction, args ...interface{}) {
	  if v != nil {
		  breadthFirst(v.sib, fn, args...)
		  fn(v, args...)
		  breadthFirst(v.child, fn, args...)
	  }
  }
#+end_src
#+begin_src latex
  The function type \texttt{nodeAction} takes as argument a node and a
  variadic list of empty interfaces.
#+end_src
#+begin_src go <<Types>>=
  type nodeAction func(*Node, ...interface{})
#+end_src
#+begin_src latex
  In the function \texttt{setFailureLink}, the root passed is retrieved
  via reflection. The failure links of nodes on levels zero (the root)
  and one refer to the root. The failure links of all other nodes
  require a bit more thought.
#+end_src
#+begin_src go <<Functions>>=
  func setFailureLink(v *Node, args ...interface{}) {
	  root := args[0].(*Node)
	  if v.depth == 0 || v.depth == 1 {
		  v.fail = root
	  } else {
		  //<<Search for link>>
	  }
  }
#+end_src
#+begin_src latex
  A failure link of some node $v$ on level 2 or greater is discovered by
  walking up the chain of failure links starting at $v$'s parent. At
  each node we look for a match to one of the children.
#+end_src
#+begin_src go <<Search for link>>=
  v.fail = root
  w := v.parent
  for w.parent != nil {
	  w = w.fail
	  c := w.findChild(v.in)
	  if c != nil {
		  v.fail = c
		  break
	  }
  }
#+end_src
#+begin_src latex
  The output set is constructed by the same tree traversal, but with
  \texttt{addOutput} instead of \texttt{setFailureLink} applied to each
  node.
#+end_src
#+begin_src go <<Construct output sets>>=
  breadthFirst(root, addOutput)
#+end_src
#+begin_src latex
  From each node, $v$, the failure links are traversed up to the root
  and any output found along the way is added to the output of $v$.
#+end_src
#+begin_src go <<Functions>>=
  func addOutput(v *Node, args ...interface{}) {
	  if v.parent == nil { return }
	  for w := v.fail; w.parent != nil; w = w.fail{
		  v.output = append(v.output, w.output...)
	  }
  }
#+end_src
#+begin_src latex
  \subsection{Method \texttt{String}}
  !\texttt{String} visualizes a keyword tree.

  It is implemented by applying the function \texttt{writeText} to every node
  in the tree.
#+end_src
#+begin_src go <<Methods>>=
  func (n *Node) String() string {
	  w := new(bytes.Buffer)
	  breadthFirst(n, writeText, w)
	  return(w.String())
  }
#+end_src
#+begin_src latex
  We import \texttt{bytes}.
#+end_src
#+begin_src go <<Imports>>=
  "bytes"
#+end_src
#+begin_src latex
  The function \texttt{writeText} writes the node's incoming edge label,
  its identifier, parent, failure link, and output set.
#+end_src
#+begin_src go <<Functions>>=
  func writeText(v *Node, args ...interface{}) {
	  w := args[0].(*bytes.Buffer)
	  //<<Write incoming character>>
	  //<<Write parent and failure link>>
	  //<<Write output set>>
  }
#+end_src
#+begin_src latex
  The root's incoming edge label is the null character, which we
  represent as underscore. Every node that is not the root starts with a
  newline. Node labels are printed one-based.
#+end_src
#+begin_src go <<Write incoming character>>=
  c := v.in
  if c == 0 {
	  c = '_'
  } else {
	  fmt.Fprintf(w, "\n")
  }
  fmt.Fprintf(w, "%c->%d", c, v.id+1)
#+end_src
#+begin_src latex
  We import \texttt{fmt}.
#+end_src
#+begin_src go <<Imports>>=
  "fmt"
#+end_src
#+begin_src latex
  The root has no parent, which we identify by 0.
#+end_src
#+begin_src go <<Write parent and failure link>>=
  var p int
  if v.parent != nil {
	  p = v.parent.id + 1
  } else {
	  p = 0
  }
  fmt.Fprintf(w, "^%d->%d", p, v.fail.id+1)
#+end_src
#+begin_src latex
  Only non-empty output sets are printed. Like node labels, pattern
  labels are represented as one-based.
#+end_src
#+begin_src go <<Write output set>>=
  l := len(v.output)
  if l > 0 {
	  fmt.Fprintf(w, "{%d", v.output[0]+1)
	  for i := 1; i < l; i ++ {
		  fmt.Fprintf(w, ",%d", v.output[i]+1)
	  }
	  fmt.Fprintf(w, "}")
  }
#+end_src

#+begin_src latex
  \subsection{Method \texttt{WriteLatex}}
  !\texttt{WriteLatex} converts a keyword tree to \LaTeX{}.

  We implement this by first working out the coordinates of nodes. Then
  we print the nodes, the match \& failure links, and the output sets.
#+end_src
#+begin_src go <<Methods>>=
  func (root *Node) WriteLatex() string {
	  w := new(bytes.Buffer)
	  //<<Calculate y-coordinates>>
	  //<<Calculate x-coordinates>>
	  //<<Print nodes>>
	  //<<Print match links>>
	  //<<Print failure links>>
	  //<<Print output sets>>
	  return(w.String())
  }
#+end_src
#+begin_src latex
  To work out the y-coordinates, take another look at the keyword tree
  in Figure~\ref{fig:kt3}. The bottom left hand corner of the image has
  coordinates (0,0), the top right hand corner (width, maxDepth). A
  y-coordinate is thus $\mbox{maxDepth}-\mbox{depth}$, which means we
  need to compute the maximum depth.
#+end_src
#+begin_src go <<Calculate y-coordinates>>=
  var maxDepth int
  breadthFirst(root, findMaxDepth, &maxDepth)
#+end_src
#+begin_src latex
  In \texttt{findMaxDepth}, we retrieves the variable \texttt{maxDepth}
  by reflection and update it where appropriate.
#+end_src
#+begin_src go <<Functions>>=
  func findMaxDepth(v *Node, args ...interface{}) {
	  maxDepth := args[0].(*int)
	  if v.depth > *maxDepth {
		  *maxDepth = v.depth
	  }
  }
#+end_src
#+begin_src latex
  The organizing principle of the x-coordinates is that the leaves are
  spread evenly along the horizontal axis and a parent's position is in
  the middle of its children. Thus we compute the horizontal distance
  between leaves and, building on that, calculate the x-coordinate of
  every node.
#+end_src
#+begin_src go <<Calculate x-coordinates>>=
  //<<Compute distance between leaves>>
  //<<Compute x-coordinates>>
#+end_src
#+begin_src latex
  The distance between leaves is the width of the tree divided by the
  number of leaves minus one. By default the number of leaves is
  understood as the tree's width, but the user can set a different value.
#+end_src
#+begin_src go <<Compute distance between leaves>>=
  var nl int
  breadthFirst(root, countLeaves, &nl)
  if width == 0 {
	  width = float64(nl)
  }
  dist := width / (float64(nl) - 1.0)
#+end_src
#+begin_src latex
  We declare the package variable \texttt{witdh}.
#+end_src
#+begin_src go <<Variables>>=
  var width float64
#+end_src
#+begin_src latex
  This has a getter,
#+end_src
#+begin_src go <<Functions>>=
  func Width() float64 {
	  return width
  }
#+end_src
#+begin_src latex
  and a setter that ensures a positive width.
#+end_src
#+begin_src go <<Functions>>=
  func SetWidth(w float64) {
	  if w > 0 {
		  width = w
	  }
  }
#+end_src
#+begin_src latex
  The function \texttt{countLeaves} takes as argument a node and a pointer to
  an integer.
#+end_src
#+begin_src go <<Functions>>=
  func countLeaves(n *Node, args ...interface{}) {
	  nl := args[0].(*int)
	  if n.child == nil {
		  *nl = *nl + 1
	  }
  }
#+end_src
#+begin_src latex
  To compute the x-coordinates, we need space to store
  them. Conveniently, \texttt{nodeId} also counts the nodes, so we can
  allocate a slice with \texttt{nodeId} entries and refer to a
  particular entry by a node's ID. Then we traverse the tree
  postorder~\cite[p. 334]{knu97:ar1} to ensure the leaves are
  encountered before their parents.
#+end_src
#+begin_src go <<Compute x-coordinates>>=
  xcoords := make([]float64, nodeId)
  var curX float64
  postorder(root, setX, &curX, dist, xcoords)
#+end_src
#+begin_src latex
  We write the postorder traversal.
#+end_src
#+begin_src go <<Functions>>=
  func postorder(v *Node, fn nodeAction, args ...interface{}) {
	  if v != nil {
		  postorder(v.child, fn, args...)
		  fn(v, args...)
		  postorder(v.sib, fn, args...)
	  }
  }
#+end_src
#+begin_src latex
  The function \texttt{setX} retrieves the arguments just passed, and
  places the node, which is either a leaf or a parent.
#+end_src
#+begin_src go <<Functions>>=
  func setX(v *Node, args ...interface{}) {
	  //<<Retrieve arguments>>
	  if v.child == nil {
		  //<<Place leaf>>
	  } else {
		  //<<Place parent>>
	  }
  }
#+end_src
#+begin_src latex
  The arguments are retrieved via reflection.
#+end_src
#+begin_src go <<Retrieve arguments>>=
  curX := args[0].(*float64)
  dist := args[1].(float64)
  xcoords := args[2].([]float64)
#+end_src
#+begin_src latex
  The leaf is placed at the current x-position, which is then
  incremented.
#+end_src
#+begin_src go <<Place leaf>>=
  xcoords[v.id] = *curX
  *curX = *curX + dist
#+end_src
#+begin_src latex
  The parent is placed in the middle of its children.
#+end_src	
#+begin_src go <<Place parent>>=
  x1 := xcoords[v.child.id]
  cp := v.child
  for cp.sib != nil {
	  cp = cp.sib
  }
  x2 := xcoords[cp.id]
  xcoords[v.id] = (x1 + x2) / 2.0
#+end_src
#+begin_src latex
  Before printing the nodes, we declare the beginning of a
  \texttt{pspicture}. Then we traverse the tree and apply the function
  \texttt{writeNode} to each node.
#+end_src
#+begin_src go <<Print nodes>>=
  fmt.Fprintf(w, "\\begin{pspicture}(0,0)(%.2f,%.2f)\n",
	  width, float64(maxDepth)+0.7)
  fmt.Fprint(w, "%% Nodes\n")
  breadthFirst(root, writeLatexNode, w, xcoords, maxDepth)
#+end_src
#+begin_src latex
  We place a node and identify it by its ID.
#+end_src
#+begin_src go <<Functions>>=
  func writeLatexNode(v *Node, args ...interface{}) {
	  w := args[0].(*bytes.Buffer)
	  xcoords := args[1].([]float64)
	  maxDepth := args[2].(int)
	  y := maxDepth - v.depth
	  x := xcoords[v.id]
	  fmt.Fprintf(w, "\\dotnode(%.3g,%d){%d}\n",
		  x, y, v.id)
  }
#+end_src
#+begin_src latex
  The match links are printed in a second traversal. They are light gray
  with 2pt separation between the arrow and the start and the end node.
#+end_src
#+begin_src go <<Print match links>>=
  fmt.Fprint(w, "%% Match links\n")
  fmt.Fprintf(w, "\\psset{linecolor=lightgray,nodesep=2pt}")
  breadthFirst(root, writeMatchLink, w)
#+end_src
#+begin_src latex
  Except for the root, each node has one incoming match-link. 
#+end_src
#+begin_src go <<Functions>>=
  func writeMatchLink(v *Node, args ...interface{}) {
	  w := args[0].(*bytes.Buffer)
	  if v.parent != nil {
		  p := v.parent.id
		  n := v.id
		  c := v.in
		  fmt.Fprintf(w, "\\ncline{->}{%d}{%d}" +
			  "\\ncput[nrot=:U]{%c}\n",
			  p, n, c)
	  }
  }
#+end_src
#+begin_src latex
  Failure links are dotted arks $v\rightarrow\mbox{fail(v)}$. To draw
  them, we need their relative x-positions of $v$ and $\mbox{fail}(v)$;
  so the x-coordinates are passed into the computation.
#+end_src
#+begin_src go <<Print failure links>>=
  fmt.Fprint(w, "%% Failure links\n")
  fmt.Fprint(w, "\\psset{linestyle=dotted}\n")
  breadthFirst(root, writeFailureLink, w, xcoords)
#+end_src
#+begin_src latex
  The failure link for the root is special.
#+end_src
#+begin_src go <<Functions>>=
  func writeFailureLink(v *Node, args ...interface{}) {
	  w := args[0].(*bytes.Buffer)
	  xcoords := args[1].([]float64)
	  if v.parent == nil {
		  //<<Write failure link for root>>
	  } else {
		  //<<Write failure link for non-root>>
	  }
  }
#+end_src
#+begin_src latex
  After reading up on nodes and their connections in
  \cite[p.162]{vos05:pst} and some trial and error, I found that the
  root's self-referential failure link is best drawn with
  \texttt{nccurve}.
#+end_src
#+begin_src go <<Write failure link for root>>=
  fmt.Fprint(w, "\\nccurve[angleA=130,angleB=50,ncurv=6]" +
	  "{->}{0}{0}\n")
#+end_src
#+begin_src latex
  An ordinary failure link is either left-tilted or right-tilted.
#+end_src
#+begin_src go <<Write failure link for non-root>>=
  angle := 50
  x1 := xcoords[v.id]
  x2 := xcoords[v.fail.id]
  if x1 > x2 { angle = -50 }
  fmt.Fprintf(w, "\\ncarc[arcangle=%d]{->}{%d}{%d}\n",
	  angle, v.id, v.fail.id)
#+end_src
#+begin_src latex
  The output sets are printed last, and we omit the newline from the
  last line.
#+end_src
#+begin_src go <<Print output sets>>=
  fmt.Fprint(w, "%% Output sets\n")
  breadthFirst(root, writeOutputSet, w)
  fmt.Fprintf(w, "\\end{pspicture}")
#+end_src
#+begin_src latex
  Output sets of leaves are placed below them, output sets of other
  nodes to their left.
#+end_src
#+begin_src go <<Functions>>=
  func writeOutputSet(v *Node, args ...interface{}) {
	  if len(v.output) == 0 { return }
	  w := args[0].(*bytes.Buffer)
	  angle := 0
	  if v.child == nil { angle = -90 }
	  fmt.Fprintf(w, "\\nput{%d}{%d}{\\{%d",
		  angle, v.id, v.output[0]+1)
	  for i := 1; i < len(v.output); i++ {
		  fmt.Fprintf(w, ",%d", v.output[i]+1)
	  }
	  fmt.Fprint(w, "\\}}\n")
  }
#+end_src
#+begin_src latex
  \subsection{Searching}
  !\texttt{Search} takes as input a text and the patterns, and returns
  !the positions of all patterns in the text.

  We do this by following Algorithm~\ref{alg:sm2}, where the text is
  traversed using two kinds of actions: waking into the tree, and
  following failure links. Notice the sentinel character terminating $T$
  in the Algorithm. We use the zero byte for this purpose.
#+end_src
#+begin_src go <<Methods>>=
  func (root *Node) Search(t []byte, p []string) []match {
	  t = append(t, 0)
	  matches := make([]match, 0)
	  v := root
	  j := 0
	  for j < len(t) - 1 {
		  //<<Walk into tree>>
		  //<<Follow failure link>>
	  }
	  return matches
  }
#+end_src
#+begin_src latex
  A match consists of a position and a pattern identifier.
#+end_src
#+begin_src go <<Types>>=
  type match struct {
	  pos, pat int
  }
#+end_src
#+begin_src latex
  While walking into the tree, we store any match found on the
  way.
#+end_src
#+begin_src go <<Walk into tree>>=
  for c := v.findChild(t[j]); c != nil; c = v.findChild(t[j]) {
	  if len(c.output) > 0 {
		  //<<Store matches>>
	  }
	  v = c
	  j++
  }
#+end_src
#+begin_src latex
  A node might refer to several matches.
#+end_src
#+begin_src go <<Store matches>>=
  for _, o := range c.output {
	  match := *new(match)
	  match.pos = j - len(p[o]) + 1
	  match.pat = o
	  matches = append(matches, match)
  }

#+end_src
#+begin_src latex
  When we run out of matches, follow the failure link, unless you're at
  the root, in which case, advance by one character.
#+end_src
#+begin_src go <<Follow failure link>>=
  if v.parent == nil {
	  j++
  } else {
	  v = v.fail
  }
#+end_src


#+begin_src latex
  \section*{Testing}
  The testing framework contains hooks for imports and functions.
#+end_src
#+begin_src go <<kt_test.go>>=
  package kt
  import (
	  "testing"
	  //<<Testing imports>>
  )
  //<<Testing functions>>
#+end_src
#+begin_src latex
  The functions consist of two testing functions, and an auxiliary
  function for constructing a keyword tree.
#+end_src
#+begin_src go <<Testing functions>>=
  func constructKt() (*Node, []string) {
	  //<<Construct test tree>>
  }
  func TestConstruction(t *testing.T) {
	  //<<Test construction>>
  }
  func TestSearching(t *testing.T) {
	  //<<Test searching>>
  }
#+end_src
#+begin_src latex
  The tree is built from the five patterns used throughout the examples,
  for example in Figure~\ref{ch:kt1}E.
#+end_src
#+begin_src go <<Construct test tree>>=
  var p []string
  p = append(p, "ATTT")
  p = append(p, "ATTC")
  p = append(p, "AT")
  p = append(p, "TG")
  p = append(p, "TT")
  tree := NewKeywordTree(p)
  return tree, p
#+end_src
#+begin_src latex
  To test tree construction, we compare the two textual representations
  of the tree we get with the precomputed result we want.
#+end_src
#+begin_src go <<Test construction>>=
  tree, _ := constructKt()
  get := tree.String() + "\n" + tree.WriteLatex() + "\n"
  fn := "constr.txt"
  want, err := ioutil.ReadFile(fn)
  if err != nil {
	  t.Errorf("couldn't open %q", fn)
  }
  if !bytes.Equal(want, []byte(get)) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
#+begin_src latex
  We import \texttt{ioutil} and \texttt{bytes}.
#+end_src
#+begin_src go <<Testing imports>>=
  "io/ioutil"
  "bytes"
#+end_src
#+begin_src latex
  When searching, we read a sequence and search it with out prefab
  keyword tree, print the matches to a buffer and compare the results we
  get to the results we want.
#+end_src
#+begin_src go <<Test searching>>=
  //<<Read sequence>>
  //<<Search sequence>>
  //<<Print matches to buffer>>
  //<<Compare matches>>
#+end_src
#+begin_src latex 
  We read an input sequence.
#+end_src
#+begin_src go <<Read sequence>>=
  fn := "test.fasta"
  file, err := os.Open(fn)
  if err != nil {
	  t.Errorf("couldn't open %q\n", fn)
  }
  scanner := fasta.NewScanner(file)
  if !scanner.ScanSequence() {
	  t.Errorf("%q doesn't contain a sequence\n", fn)
  }
  seq := scanner.Sequence()
#+end_src
#+begin_src latex
  We import \texttt{os} and \texttt{fasta}.
#+end_src
#+begin_src go <<Testing imports>>=
  "os"
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  A single function call returns the pattern matches in the sequence.
#+end_src
#+begin_src go <<Search sequence>>=
  tree, p := constructKt()
  matches := tree.Search(seq.Data(), p)
#+end_src
#+begin_src latex
  We iterate over the matches to print them to a buffer.
#+end_src
#+begin_src go <<Print matches to buffer>>=
  buf := new(bytes.Buffer)
  for _, match := range matches {
	  fmt.Fprintf(buf, "%s:%d\n", p[match.pat], match.pos+1)
  }
  get := buf.Bytes()
#+end_src
#+begin_src latex
  We import \texttt{fmt}.
#+end_src
#+begin_src go <<Testing imports>>=
  "fmt"
#+end_src
#+begin_src latex
  The results we want are stored in \texttt{search.txt}.
#+end_src
#+begin_src go <<Compare matches>>=
  fn = "search.txt"
  want, err := ioutil.ReadFile(fn)
  if err != nil {
	  t.Errorf("couldn't read %q\n", fn)
  }
  if !bytes.Equal(want, get) {
	  t.Errorf("want:\n%s\nget:\n%s\n", want, get)
  }
#+end_src
